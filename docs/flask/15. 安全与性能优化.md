# ğŸ”’âš¡ 15. å®‰å…¨ä¸æ€§èƒ½ä¼˜åŒ–

åœ¨ç°ä»£Webåº”ç”¨å¼€å‘ä¸­ï¼Œå®‰å…¨æ€§å’Œæ€§èƒ½æ˜¯ä¸¤ä¸ªä¸å¯å¿½è§†çš„å…³é”®è¦ç´ ã€‚æœ¬ç« å°†æ·±å…¥æ¢è®¨Flaskåº”ç”¨çš„å®‰å…¨é˜²æŠ¤ç­–ç•¥å’Œæ€§èƒ½ä¼˜åŒ–æŠ€æœ¯ï¼Œå¸®åŠ©ä½ æ„å»ºæ—¢å®‰å…¨åˆé«˜æ•ˆçš„Webåº”ç”¨ã€‚

## ğŸ›¡ï¸ 15.1 Web å®‰å…¨æœ€ä½³å®è·µ

### 15.1.1 å¸¸è§Webå®‰å…¨å¨èƒ

```mermaid
graph TD
    A[Webå®‰å…¨å¨èƒ] --> B[æ³¨å…¥æ”»å‡»]
    A --> C[è·¨ç«™è„šæœ¬XSS]
    A --> D[è·¨ç«™è¯·æ±‚ä¼ªé€ CSRF]
    A --> E[ä¼šè¯åŠ«æŒ]
    A --> F[æ–‡ä»¶ä¸Šä¼ æ¼æ´]
    
    B --> B1[SQLæ³¨å…¥]
    B --> B2[NoSQLæ³¨å…¥]
    B --> B3[å‘½ä»¤æ³¨å…¥]
    
    C --> C1[å­˜å‚¨å‹XSS]
    C --> C2[åå°„å‹XSS]
    C --> C3[DOMå‹XSS]
```

### 15.1.2 è¾“å…¥éªŒè¯ä¸æ•°æ®æ¸…ç†

**æ ¸å¿ƒåŸåˆ™**ï¼šæ°¸è¿œä¸è¦ä¿¡ä»»ç”¨æˆ·è¾“å…¥
app/security/validators.py
```python
from flask import request
from werkzeug.utils import secure_filename
import re
import bleach

class SecurityValidator:
    @staticmethod
    def sanitize_html(content):
        """æ¸…ç†HTMLå†…å®¹ï¼Œé˜²æ­¢XSSæ”»å‡»"""
        allowed_tags = ['p', 'br', 'strong', 'em', 'ul', 'ol', 'li']
        return bleach.clean(content, tags=allowed_tags, strip=True)
    
    @staticmethod
    def validate_filename(filename):
        """éªŒè¯æ–‡ä»¶åå®‰å…¨æ€§"""
        if not filename or '..' in filename:
            return False
        return secure_filename(filename) == filename
    
    @staticmethod
    def validate_sql_input(input_str):
        """åŸºç¡€SQLæ³¨å…¥æ£€æµ‹"""
        dangerous_patterns = [
            r'(union|select|insert|update|delete|drop|create|alter)',
            r'(script|javascript|vbscript)',
            r'(\<|\>|\&|\"|\'|\;|\(|\))'
        ]
        
        for pattern in dangerous_patterns:
            if re.search(pattern, input_str, re.IGNORECASE):
                return False
        return True
```

### 15.1.3 SQLæ³¨å…¥é˜²æŠ¤

**ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢**ï¼š
app/models/user.py
```python
from sqlalchemy import text
from app import db

class User(db.Model):
    # ... æ¨¡å‹å®šä¹‰ ...
    
    @classmethod
    def find_by_email_safe(cls, email):
        """å®‰å…¨çš„ç”¨æˆ·æŸ¥è¯¢æ–¹æ³•"""
        # âœ… æ­£ç¡®ï¼šä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢
        return cls.query.filter(cls.email == email).first()
    
    @classmethod
    def search_users_safe(cls, keyword):
        """å®‰å…¨çš„ç”¨æˆ·æœç´¢"""
        # âœ… æ­£ç¡®ï¼šä½¿ç”¨SQLAlchemyçš„text()å’Œå‚æ•°ç»‘å®š
        query = text(
            "SELECT * FROM users WHERE username LIKE :keyword OR email LIKE :keyword"
        )
        return db.session.execute(query, {'keyword': f'%{keyword}%'}).fetchall()
```

**âŒ å±é™©ç¤ºä¾‹ï¼ˆæ°¸è¿œä¸è¦è¿™æ ·åšï¼‰**ï¼š
```python
# å±é™©ï¼šç›´æ¥å­—ç¬¦ä¸²æ‹¼æ¥
def unsafe_query(user_input):
    query = f"SELECT * FROM users WHERE name = '{user_input}'"
    # æ”»å‡»è€…å¯ä»¥è¾“å…¥: ' OR '1'='1' --
    return db.session.execute(query)
```

### 15.1.4 XSSé˜²æŠ¤ç­–ç•¥
app/utils/security.py
```python
from markupsafe import Markup, escape
from flask import current_app

class XSSProtection:
    @staticmethod
    def safe_render(content, allow_html=False):
        """å®‰å…¨æ¸²æŸ“ç”¨æˆ·å†…å®¹"""
        if not allow_html:
            return escape(content)
        
        # ä½¿ç”¨ç™½åå•æ–¹å¼æ¸…ç†HTML
        return Markup(bleach.clean(
            content,
            tags=['p', 'br', 'strong', 'em', 'a'],
            attributes={'a': ['href', 'title']},
            protocols=['http', 'https', 'mailto']
        ))
    
    @staticmethod
    def create_csp_header():
        """åˆ›å»ºå†…å®¹å®‰å…¨ç­–ç•¥å¤´"""
        return {
            'Content-Security-Policy': (
                "default-src 'self'; "
                "script-src 'self' 'unsafe-inline' https://cdn.jsdelivr.net; "
                "style-src 'self' 'unsafe-inline' https://fonts.googleapis.com; "
                "img-src 'self' data: https:; "
                "font-src 'self' https://fonts.gstatic.com;"
            )
        }
```

**æ¨¡æ¿ä¸­çš„å®‰å…¨å®è·µ**ï¼š
templates/base.html
```html
<!-- âœ… æ­£ç¡®ï¼šè‡ªåŠ¨è½¬ä¹‰ -->
<p>ç”¨æˆ·åï¼š{{ user.username }}</p>

<!-- âœ… æ­£ç¡®ï¼šæ˜ç¡®æ ‡è®°ä¸ºå®‰å…¨å†…å®¹ -->
<div>{{ content | safe }}</div>

<!-- âŒ å±é™©ï¼šç›´æ¥è¾“å‡ºåŸå§‹HTML -->
<div>{{ user_input | safe }}</div>
```

## ğŸ” 15.2 HTTPS é…ç½®ä¸è¯ä¹¦ç®¡ç†

### 15.2.1 HTTPSé…ç½®æµç¨‹

```mermaid
sequenceDiagram
    participant C as å®¢æˆ·ç«¯
    participant S as æœåŠ¡å™¨
    participant CA as è¯ä¹¦é¢å‘æœºæ„
    
    Note over S,CA: 1. è¯ä¹¦ç”³è¯·ä¸å®‰è£…
    S->>CA: ç”³è¯·SSLè¯ä¹¦
    CA->>S: é¢å‘è¯ä¹¦
    
    Note over C,S: 2. HTTPSæ¡æ‰‹è¿‡ç¨‹
    C->>S: ClientHello
    S->>C: ServerHello + è¯ä¹¦
    C->>S: éªŒè¯è¯ä¹¦
    C->>S: åŠ å¯†å¯†é’¥äº¤æ¢
    Note over C,S: 3. å»ºç«‹å®‰å…¨è¿æ¥
```

### 15.2.2 Flask HTTPSé…ç½®
app/config.py
```python
import os
from datetime import timedelta

class ProductionConfig:
    # HTTPSå¼ºåˆ¶é…ç½®
    PREFERRED_URL_SCHEME = 'https'
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = 'Lax'
    
    # HSTSé…ç½®
    PERMANENT_SESSION_LIFETIME = timedelta(hours=1)
    
    # SSLè¯ä¹¦è·¯å¾„
    SSL_CERT_PATH = os.environ.get('SSL_CERT_PATH', '/etc/ssl/certs/app.crt')
    SSL_KEY_PATH = os.environ.get('SSL_KEY_PATH', '/etc/ssl/private/app.key')
```

app/__init__.py
```python
from flask_talisman import Talisman

def create_app(config_name):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    
    # é…ç½®HTTPSå®‰å…¨å¤´
    if config_name == 'production':
        Talisman(app, 
            force_https=True,
            strict_transport_security=True,
            strict_transport_security_max_age=31536000,  # 1å¹´
            content_security_policy={
                'default-src': "'self'",
                'script-src': "'self' 'unsafe-inline'",
                'style-src': "'self' 'unsafe-inline'"
            }
        )
    
    return app
```

### 15.2.3 Let's Encryptè‡ªåŠ¨åŒ–è¯ä¹¦ç®¡ç†

```bash
# å®‰è£…Certbot
sudo apt-get install certbot python3-certbot-nginx

# è·å–è¯ä¹¦
sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com

# è®¾ç½®è‡ªåŠ¨ç»­æœŸ
sudo crontab -e
# æ·»åŠ ï¼š0 12 * * * /usr/bin/certbot renew --quiet
```

## ğŸ›¡ï¸ 15.3 å®‰å…¨å¤´é…ç½®

### 15.3.1 å…³é”®å®‰å…¨å¤´è¯´æ˜

```mermaid
graph LR
    A[å®‰å…¨å¤´é…ç½®] --> B[HSTS]
    A --> C[CSP]
    A --> D[X-Frame-Options]
    A --> E[X-Content-Type-Options]
    A --> F[Referrer-Policy]
    
    B --> B1[å¼ºåˆ¶HTTPS]
    C --> C1[é˜²æ­¢XSS]
    D --> D1[é˜²æ­¢ç‚¹å‡»åŠ«æŒ]
    E --> E1[é˜²æ­¢MIMEå—…æ¢]
    F --> F1[æ§åˆ¶å¼•ç”¨ä¿¡æ¯]
```

### 15.3.2 å®‰å…¨å¤´ä¸­é—´ä»¶å®ç°
app/middleware/security.py
```python
from flask import g, request, current_app

class SecurityHeaders:
    def __init__(self, app=None):
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        app.after_request(self.add_security_headers)
    
    def add_security_headers(self, response):
        """æ·»åŠ å®‰å…¨å“åº”å¤´"""
        security_headers = {
            # é˜²æ­¢ç‚¹å‡»åŠ«æŒ
            'X-Frame-Options': 'DENY',
            
            # é˜²æ­¢MIMEç±»å‹å—…æ¢
            'X-Content-Type-Options': 'nosniff',
            
            # XSSä¿æŠ¤
            'X-XSS-Protection': '1; mode=block',
            
            # å¼•ç”¨ç­–ç•¥
            'Referrer-Policy': 'strict-origin-when-cross-origin',
            
            # æƒé™ç­–ç•¥
            'Permissions-Policy': (
                'geolocation=(), microphone=(), camera=()'
            )
        }
        
        # ä»…åœ¨HTTPSä¸‹æ·»åŠ HSTS
        if request.is_secure:
            security_headers['Strict-Transport-Security'] = (
                'max-age=31536000; includeSubDomains; preload'
            )
        
        for header, value in security_headers.items():
            response.headers[header] = value
        
        return response
```

## ğŸ“Š 15.4 æ€§èƒ½ç›‘æ§ä¸ä¼˜åŒ–

### 15.4.1 æ€§èƒ½ç›‘æ§æ¶æ„

```mermaid
graph TB
    A[Flaskåº”ç”¨] --> B[æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶]
    B --> C[æŒ‡æ ‡æ”¶é›†]
    B --> D[æ—¥å¿—è®°å½•]
    
    C --> E[å“åº”æ—¶é—´]
    C --> F[å†…å­˜ä½¿ç”¨]
    C --> G[æ•°æ®åº“æŸ¥è¯¢]
    C --> H[ç¼“å­˜å‘½ä¸­ç‡]
    
    D --> I[é”™è¯¯æ—¥å¿—]
    D --> J[è®¿é—®æ—¥å¿—]
    D --> K[æ€§èƒ½æ—¥å¿—]
    
    E --> L[Prometheus]
    F --> L
    G --> L
    H --> L
    
    L --> M[Grafanaä»ªè¡¨æ¿]
```

### 15.4.2 æ€§èƒ½ç›‘æ§ä¸­é—´ä»¶
app/middleware/performance.py
```python
import time
import psutil
from flask import g, request, current_app
from functools import wraps

class PerformanceMonitor:
    def __init__(self, app=None):
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        app.before_request(self.before_request)
        app.after_request(self.after_request)
    
    def before_request(self):
        """è¯·æ±‚å¼€å§‹æ—¶è®°å½•"""
        g.start_time = time.time()
        g.start_memory = psutil.Process().memory_info().rss
    
    def after_request(self, response):
        """è¯·æ±‚ç»“æŸæ—¶è®¡ç®—æ€§èƒ½æŒ‡æ ‡"""
        if hasattr(g, 'start_time'):
            duration = time.time() - g.start_time
            memory_used = psutil.Process().memory_info().rss - g.start_memory
            
            # è®°å½•æ€§èƒ½æŒ‡æ ‡
            current_app.logger.info(
                f"Performance: {request.endpoint} - "
                f"Duration: {duration:.3f}s, "
                f"Memory: {memory_used/1024/1024:.2f}MB, "
                f"Status: {response.status_code}"
            )
            
            # æ…¢æŸ¥è¯¢è­¦å‘Š
            if duration > 1.0:  # è¶…è¿‡1ç§’
                current_app.logger.warning(
                    f"Slow request detected: {request.url} took {duration:.3f}s"
                )
        
        return response

def monitor_function_performance(func):
    """å‡½æ•°æ€§èƒ½ç›‘æ§è£…é¥°å™¨"""
    @wraps(func)
    def wrapper(*args, **kwargs):
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            return result
        finally:
            duration = time.time() - start_time
            current_app.logger.debug(
                f"Function {func.__name__} took {duration:.3f}s"
            )
    return wrapper
```

### 15.4.3 æ•°æ®åº“æŸ¥è¯¢ä¼˜åŒ–
app/models/optimized.py
```python
from sqlalchemy import event
from sqlalchemy.engine import Engine
import time
import logging

# æ•°æ®åº“æŸ¥è¯¢æ€§èƒ½ç›‘æ§
logging.basicConfig()
logger = logging.getLogger("sqlalchemy.engine")
logger.setLevel(logging.INFO)

@event.listens_for(Engine, "before_cursor_execute")
def before_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    conn.info.setdefault('query_start_time', []).append(time.time())

@event.listens_for(Engine, "after_cursor_execute")
def after_cursor_execute(conn, cursor, statement, parameters, context, executemany):
    total = time.time() - conn.info['query_start_time'].pop(-1)
    if total > 0.1:  # æ…¢æŸ¥è¯¢é˜ˆå€¼100ms
        logger.warning(f"Slow query: {total:.3f}s - {statement[:100]}...")

class OptimizedUser(db.Model):
    # ... åŸºç¡€æ¨¡å‹å®šä¹‰ ...
    
    @classmethod
    def get_users_with_posts(cls, limit=10):
        """ä¼˜åŒ–çš„ç”¨æˆ·å’Œæ–‡ç« è”åˆæŸ¥è¯¢"""
        return cls.query.options(
            db.joinedload(cls.posts)  # é¢„åŠ è½½å…³è”æ•°æ®
        ).limit(limit).all()
    
    @classmethod
    def search_users_optimized(cls, keyword, page=1, per_page=20):
        """ä¼˜åŒ–çš„ç”¨æˆ·æœç´¢"""
        return cls.query.filter(
            db.or_(
                cls.username.ilike(f'%{keyword}%'),
                cls.email.ilike(f'%{keyword}%')
            )
        ).paginate(
            page=page, per_page=per_page, error_out=False
        )
```

## ğŸš€ 15.5 ç¼“å­˜ç­–ç•¥å®æ–½

### 15.5.1 å¤šå±‚ç¼“å­˜æ¶æ„

```mermaid
graph TD
    A[ç”¨æˆ·è¯·æ±‚] --> B[CDNç¼“å­˜]
    B --> C[åå‘ä»£ç†ç¼“å­˜]
    C --> D[åº”ç”¨å±‚ç¼“å­˜]
    D --> E[æ•°æ®åº“æŸ¥è¯¢ç¼“å­˜]
    E --> F[æ•°æ®åº“]
    
    B --> B1[é™æ€èµ„æº]
    C --> C1[é¡µé¢ç¼“å­˜]
    D --> D1[Redisç¼“å­˜]
    E --> E1[æŸ¥è¯¢ç»“æœç¼“å­˜]
```

### 15.5.2 Flaskç¼“å­˜å®ç°
app/cache/manager.py
```python
from flask_caching import Cache
from functools import wraps
import hashlib
import json

cache = Cache()

class CacheManager:
    def __init__(self, app=None):
        if app:
            self.init_app(app)
    
    def init_app(self, app):
        cache.init_app(app, config={
            'CACHE_TYPE': 'redis',
            'CACHE_REDIS_URL': app.config.get('REDIS_URL', 'redis://localhost:6379/0'),
            'CACHE_DEFAULT_TIMEOUT': 300
        })
    
    @staticmethod
    def cache_key(*args, **kwargs):
        """ç”Ÿæˆç¼“å­˜é”®"""
        key_data = {'args': args, 'kwargs': kwargs}
        key_string = json.dumps(key_data, sort_keys=True)
        return hashlib.md5(key_string.encode()).hexdigest()
    
    @staticmethod
    def cached_view(timeout=300, key_prefix='view'):
        """è§†å›¾ç¼“å­˜è£…é¥°å™¨"""
        def decorator(f):
            @wraps(f)
            def wrapper(*args, **kwargs):
                cache_key = f"{key_prefix}:{CacheManager.cache_key(*args, **kwargs)}"
                
                # å°è¯•ä»ç¼“å­˜è·å–
                cached_result = cache.get(cache_key)
                if cached_result is not None:
                    return cached_result
                
                # æ‰§è¡Œå‡½æ•°å¹¶ç¼“å­˜ç»“æœ
                result = f(*args, **kwargs)
                cache.set(cache_key, result, timeout=timeout)
                return result
            return wrapper
        return decorator
```

### 15.5.3 æ™ºèƒ½ç¼“å­˜ç­–ç•¥
app/services/cache_service.py
```python
from app.cache.manager import cache, CacheManager
from flask import current_app
import time

class SmartCacheService:
    @staticmethod
    def get_or_set(key, callback, timeout=300, refresh_threshold=0.8):
        """æ™ºèƒ½ç¼“å­˜ï¼šåœ¨è¿‡æœŸå‰ä¸»åŠ¨åˆ·æ–°"""
        cache_data = cache.get(key)
        
        if cache_data is None:
            # ç¼“å­˜æœªå‘½ä¸­ï¼Œæ‰§è¡Œå›è°ƒ
            data = callback()
            cache.set(key, {
                'data': data,
                'timestamp': time.time()
            }, timeout=timeout)
            return data
        
        # æ£€æŸ¥æ˜¯å¦éœ€è¦åˆ·æ–°
        age = time.time() - cache_data['timestamp']
        if age > (timeout * refresh_threshold):
            # å¼‚æ­¥åˆ·æ–°ç¼“å­˜
            try:
                fresh_data = callback()
                cache.set(key, {
                    'data': fresh_data,
                    'timestamp': time.time()
                }, timeout=timeout)
                return fresh_data
            except Exception as e:
                current_app.logger.error(f"Cache refresh failed: {e}")
                return cache_data['data']  # è¿”å›æ—§æ•°æ®
        
        return cache_data['data']
    
    @staticmethod
    def invalidate_pattern(pattern):
        """æŒ‰æ¨¡å¼æ¸…é™¤ç¼“å­˜"""
        # æ³¨æ„ï¼šè¿™éœ€è¦Redisæ”¯æŒ
        keys = cache.cache._read_clients.keys(pattern)
        if keys:
            cache.delete_many(*keys)
```

## ğŸ—„ï¸ 15.6 æ•°æ®åº“æ€§èƒ½è°ƒä¼˜

### 15.6.1 æ•°æ®åº“æ€§èƒ½ä¼˜åŒ–ç­–ç•¥

```mermaid
graph LR
    A[æ•°æ®åº“ä¼˜åŒ–] --> B[ç´¢å¼•ä¼˜åŒ–]
    A --> C[æŸ¥è¯¢ä¼˜åŒ–]
    A --> D[è¿æ¥æ± é…ç½®]
    A --> E[åˆ†åŒºåˆ†è¡¨]
    
    B --> B1[å¤åˆç´¢å¼•]
    B --> B2[è¦†ç›–ç´¢å¼•]
    C --> C1[æŸ¥è¯¢é‡å†™]
    C --> C2[é¢„ç¼–è¯‘è¯­å¥]
    D --> D1[è¿æ¥æ•°æ§åˆ¶]
    D --> D2[è¶…æ—¶è®¾ç½®]
```

### 15.6.2 æ•°æ®åº“è¿æ¥ä¼˜åŒ–
app/config.py
```python
class DatabaseConfig:
    # æ•°æ®åº“è¿æ¥æ± é…ç½®
    SQLALCHEMY_ENGINE_OPTIONS = {
        'pool_size': 10,          # è¿æ¥æ± å¤§å°
        'pool_timeout': 20,       # è·å–è¿æ¥è¶…æ—¶æ—¶é—´
        'pool_recycle': 3600,     # è¿æ¥å›æ”¶æ—¶é—´ï¼ˆ1å°æ—¶ï¼‰
        'pool_pre_ping': True,    # è¿æ¥å‰æ£€æŸ¥
        'max_overflow': 20,       # æœ€å¤§æº¢å‡ºè¿æ¥æ•°
        'echo': False,            # ç”Ÿäº§ç¯å¢ƒå…³é—­SQLæ—¥å¿—
    }
    
    # æŸ¥è¯¢ä¼˜åŒ–é…ç½®
    SQLALCHEMY_RECORD_QUERIES = True
    DATABASE_QUERY_TIMEOUT = 0.5  # æ…¢æŸ¥è¯¢é˜ˆå€¼
```

### 15.6.3 æŸ¥è¯¢æ€§èƒ½åˆ†æå·¥å…·
app/utils/db_profiler.py
```python
from flask_sqlalchemy import get_debug_queries
from flask import current_app, g

class DatabaseProfiler:
    @staticmethod
    def analyze_queries():
        """åˆ†ææ•°æ®åº“æŸ¥è¯¢æ€§èƒ½"""
        queries = get_debug_queries()
        
        if not queries:
            return
        
        slow_queries = []
        total_time = 0
        
        for query in queries:
            total_time += query.duration
            
            if query.duration > current_app.config.get('DATABASE_QUERY_TIMEOUT', 0.5):
                slow_queries.append({
                    'statement': query.statement,
                    'parameters': query.parameters,
                    'duration': query.duration,
                    'context': query.context
                })
        
        # è®°å½•æ€§èƒ½ç»Ÿè®¡
        current_app.logger.info(
            f"Database Performance: {len(queries)} queries, "
            f"Total time: {total_time:.3f}s"
        )
        
        # è®°å½•æ…¢æŸ¥è¯¢
        for slow_query in slow_queries:
            current_app.logger.warning(
                f"Slow Query ({slow_query['duration']:.3f}s): "
                f"{slow_query['statement'][:200]}..."
            )
        
        return {
            'total_queries': len(queries),
            'total_time': total_time,
            'slow_queries': len(slow_queries)
        }
```

## ğŸ“‹ å®‰å…¨ä¸æ€§èƒ½æ£€æŸ¥æ¸…å•

### ğŸ”’ å®‰å…¨æ£€æŸ¥æ¸…å•
- [ ] æ‰€æœ‰ç”¨æˆ·è¾“å…¥éƒ½ç»è¿‡éªŒè¯å’Œæ¸…ç†
- [ ] ä½¿ç”¨å‚æ•°åŒ–æŸ¥è¯¢é˜²æ­¢SQLæ³¨å…¥
- [ ] å®æ–½XSSé˜²æŠ¤æªæ–½
- [ ] é…ç½®CSRFä¿æŠ¤
- [ ] å¯ç”¨HTTPSå’Œå®‰å…¨å¤´
- [ ] å®æ–½é€‚å½“çš„ä¼šè¯ç®¡ç†
- [ ] å®šæœŸæ›´æ–°ä¾èµ–åŒ…
- [ ] é…ç½®é€‚å½“çš„é”™è¯¯å¤„ç†

### âš¡ æ€§èƒ½æ£€æŸ¥æ¸…å•
- [ ] å®æ–½å¤šå±‚ç¼“å­˜ç­–ç•¥
- [ ] ä¼˜åŒ–æ•°æ®åº“æŸ¥è¯¢å’Œç´¢å¼•
- [ ] é…ç½®è¿æ¥æ± 
- [ ] å¯ç”¨Gzipå‹ç¼©
- [ ] ä¼˜åŒ–é™æ€èµ„æºåŠ è½½
- [ ] å®æ–½æ€§èƒ½ç›‘æ§
- [ ] è®¾ç½®é€‚å½“çš„è¶…æ—¶é…ç½®
- [ ] ä½¿ç”¨CDNåŠ é€Ÿé™æ€èµ„æº

---

é€šè¿‡æœ¬ç« çš„å­¦ä¹ ï¼Œä½ å·²ç»æŒæ¡äº†Flaskåº”ç”¨å®‰å…¨é˜²æŠ¤å’Œæ€§èƒ½ä¼˜åŒ–çš„æ ¸å¿ƒæŠ€æœ¯ã€‚è®°ä½ï¼Œå®‰å…¨å’Œæ€§èƒ½ä¼˜åŒ–æ˜¯ä¸€ä¸ªæŒç»­çš„è¿‡ç¨‹ï¼Œéœ€è¦åœ¨å¼€å‘çš„æ¯ä¸ªé˜¶æ®µéƒ½ä¿æŒè­¦æƒ•å’Œå…³æ³¨ã€‚åœ¨ä¸‹ä¸€ç« ä¸­ï¼Œæˆ‘ä»¬å°†æ¢è®¨ç»¼åˆé¡¹ç›®å®æˆ˜ï¼Œå°†æ‰€å­¦çŸ¥è¯†åº”ç”¨åˆ°å®é™…é¡¹ç›®ä¸­ã€‚