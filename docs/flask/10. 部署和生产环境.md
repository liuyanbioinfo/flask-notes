# 10. 部署和生产环境
## 10.1 部署准备：配置和安全性
在生产环境部署前，需要进行充分的准备和配置，确保应用的安全性和稳定性。

**环境配置管理**：

```python
# config.py
import os
from dotenv import load_dotenv

load_dotenv()  # 加载环境变量

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'dev-key-change-in-production'
    SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or \
        'sqlite:///' + os.path.join(os.path.abspath(os.path.dirname(__file__)), 'app.db')
    SQLALCHEMY_TRACK_MODIFICATIONS = False
    
    # 邮件配置
    MAIL_SERVER = os.environ.get('MAIL_SERVER', 'smtp.gmail.com')
    MAIL_PORT = int(os.environ.get('MAIL_PORT', 587))
    MAIL_USE_TLS = os.environ.get('MAIL_USE_TLS', 'true').lower() in ['true', 'on', '1']
    MAIL_USERNAME = os.environ.get('MAIL_USERNAME')
    MAIL_PASSWORD = os.environ.get('MAIL_PASSWORD')
    
    # 性能配置
    JSONIFY_PRETTYPRINT_REGULAR = False

class ProductionConfig(Config):
    DEBUG = False
    TESTING = False
    
    # 生产环境特定配置
    PREFERRED_URL_SCHEME = 'https'
    SESSION_COOKIE_SECURE = True
    REMEMBER_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    REMEMBER_COOKIE_HTTPONLY = True

class DevelopmentConfig(Config):
    DEBUG = True
    DEVELOPMENT = True

class TestingConfig(Config):
    TESTING = True
    SQLALCHEMY_DATABASE_URI = 'sqlite:///:memory:'
    WTF_CSRF_ENABLED = False

# 环境配置映射
config = {
    'production': ProductionConfig,
    'development': DevelopmentConfig,
    'testing': TestingConfig,
    'default': DevelopmentConfig
}
```

**安全配置检查清单**：

```bash
# 安全审计脚本 security_check.py
import os
import re
from flask import current_app

def check_security():
    issues = []
    
    # 检查密钥强度
    secret_key = current_app.config.get('SECRET_KEY')
    if secret_key and len(secret_key) < 16:
        issues.append('SECRET_KEY太短，建议至少32个字符')
    
    # 检查调试模式
    if current_app.config.get('DEBUG'):
        issues.append('生产环境不应启用DEBUG模式')
    
    # 检查数据库连接
    db_uri = current_app.config.get('SQLALCHEMY_DATABASE_URI', '')
    if 'sqlite' in db_uri and 'production' in os.environ.get('FLASK_ENV', ''):
        issues.append('生产环境不建议使用SQLite')
    
    return issues
```

## 10.2 使用 WSGI 服务器（如 Gunicorn）
生产环境不应使用Flask内置的开发服务器，而应该使用专业的WSGI服务器。

**Gunicorn 配置**：

```python
# gunicorn.conf.py
import multiprocessing
import os

# 服务器套接字
bind = '0.0.0.0:5000'
backlog = 2048

# 工作进程
workers = multiprocessing.cpu_count() * 2 + 1
worker_class = 'sync'
worker_connections = 1000
timeout = 30
keepalive = 2

# 日志配置
accesslog = '/var/log/gunicorn/access.log'
errorlog = '/var/log/gunicorn/error.log'
loglevel = 'info'

# 进程名称
proc_name = 'flask_app'

# 服务器钩子
def on_starting(server):
    """服务器启动时执行"""
    print("服务器正在启动...")

def when_ready(server):
    """服务器准备就绪时执行"""
    print("服务器准备就绪，开始接受连接")

def pre_fork(server, worker):
    """fork工作进程前执行"""
    pass

def post_fork(server, worker):
    """fork工作进程后执行"""
    pass
```

**启动脚本**：

```bash
#!/bin/bash
# run_production.sh

# 设置环境变量
export FLASK_ENV=production
export DATABASE_URL="postgresql://user:password@localhost/production_db"
export SECRET_KEY="your-production-secret-key"

# 创建日志目录
mkdir -p /var/log/gunicorn

# 启动Gunicorn
exec gunicorn -c gunicorn.conf.py "app:create_app()"
```

**Systemd 服务配置**：

```properties
# /etc/systemd/system/flask-app.service
[Unit]
Description=Flask Application
After=network.target

[Service]
User=www-data
Group=www-data
WorkingDirectory=/path/to/your/app
Environment="PATH=/path/to/your/venv/bin"
Environment="FLASK_ENV=production"
ExecStart=/path/to/your/venv/bin/gunicorn -c gunicorn.conf.py "app:create_app()"

Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
```

## 10.3 部署到云平台
### Heroku 部署
```yaml
# Procfile
web: gunicorn -w 4 -b 0.0.0.0:$PORT app:app

# runtime.txt
python-3.9.7

# app.json
{
  "name": "Flask Application",
  "description": "A production-ready Flask application",
  "keywords": ["python", "flask"],
  "env": {
    "SECRET_KEY": {
      "description": "Flask secret key",
      "generator": "secret"
    },
    "FLASK_ENV": {
      "value": "production"
    }
  },
  "addons": [
    "heroku-postgresql:hobby-dev"
  ]
}
```

### AWS Elastic Beanstalk
```bash
# .ebextensions/flask.config
option_settings:
  aws:elasticbeanstalk:container:python:
    WSGIPath: application.py
  aws:elasticbeanstalk:application:environment:
    FLASK_ENV: production
```

### Docker 部署
```dockerfile
# Dockerfile
FROM python:3.9-slim

# 设置工作目录
WORKDIR /app

# 安装系统依赖
RUN apt-get update && apt-get install -y \
    build-essential \
    libpq-dev \
    && rm -rf /var/lib/apt/lists/*

# 复制依赖文件并安装
COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

# 复制应用代码
COPY . .

# 创建非root用户
RUN useradd -m -u 1000 appuser
USER appuser

# 暴露端口
EXPOSE 5000

# 启动命令
CMD ["gunicorn", "-w", "4", "-b", "0.0.0.0:5000", "app:create_app()"]
```

**Docker Compose 配置**：

```yaml
# docker-compose.yml
version: '3.8'

services:
  web:
    build: .
    ports:
      - "5000:5000"
    environment:
      - FLASK_ENV=production
      - DATABASE_URL=postgresql://user:password@db:5432/app_db
    depends_on:
      - db
    volumes:
      - ./logs:/app/logs

  db:
    image: postgres:13
    environment:
      - POSTGRES_DB=app_db
      - POSTGRES_USER=user
      - POSTGRES_PASSWORD=password
    volumes:
      - postgres_data:/var/lib/postgresql/data

volumes:
  postgres_data:
```

## 10.4 域名和 HTTPS 设置
**Nginx 反向代理配置**：

```nginx
# /etc/nginx/sites-available/flask-app
server {
    listen 80;
    server_name yourdomain.com www.yourdomain.com;
    
    # 重定向HTTP到HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name yourdomain.com www.yourdomain.com;
    
    # SSL证书配置
    ssl_certificate /etc/letsencrypt/live/yourdomain.com/fullchain.pem;
    ssl_certificate_key /etc/letsencrypt/live/yourdomain.com/privkey.pem;
    
    # SSL优化配置
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # 静态文件服务
    location /static {
        alias /path/to/your/app/static;
        expires 1y;
        add_header Cache-Control "public, immutable";
    }
    
    # 代理配置
    location / {
        proxy_pass http://localhost:5000;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # WebSocket支持
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
    }
    
    # 安全头
    add_header X-Frame-Options DENY;
    add_header X-Content-Type-Options nosniff;
    add_header X-XSS-Protection "1; mode=block";
}
```

**Let's Encrypt SSL 证书**：

```bash
# 安装Certbot
sudo apt install certbot python3-certbot-nginx

# 获取SSL证书
sudo certbot --nginx -d yourdomain.com -d www.yourdomain.com

# 设置自动续期
echo "0 12 * * * /usr/bin/certbot renew --quiet" | sudo tee -a /etc/crontab > /dev/null
```

## 10.5 监控和维护
**应用健康检查**：

```python
@app.route('/health')
def health_check():
    """健康检查端点"""
    try:
        # 检查数据库连接
        db.session.execute('SELECT 1')
        db_healthy = True
    except Exception:
        db_healthy = False
    
    # 检查Redis连接
    try:
        redis.ping()
        redis_healthy = True
    except Exception:
        redis_healthy = False
    
    status = {
        'status': 'healthy' if db_healthy and redis_healthy else 'unhealthy',
        'timestamp': datetime.utcnow().isoformat(),
        'components': {
            'database': 'healthy' if db_healthy else 'unhealthy',
            'redis': 'healthy' if redis_healthy else 'unhealthy'
        }
    }
    
    status_code = 200 if status['status'] == 'healthy' else 503
    return jsonify(status), status_code
```

**日志监控配置**：

```python
# 结构化日志配置
import json
import logging
from pythonjsonlogger import jsonlogger

class StructuredLogger:
    def __init__(self, app=None):
        self.app = app
        if app is not None:
            self.init_app(app)
    
    def init_app(self, app):
        # 配置JSON格式日志
        handler = logging.StreamHandler()
        formatter = jsonlogger.JsonFormatter(
            '%(asctime)s %(levelname)s %(name)s %(message)s'
        )
        handler.setFormatter(formatter)
        
        app.logger.addHandler(handler)
        app.logger.setLevel(logging.INFO)

# 应用性能监控
from prometheus_flask_exporter import PrometheusMetrics

metrics = PrometheusMetrics(app)

# 自定义指标
request_duration = metrics.info(
    'app_request_duration_seconds', 
    'Request duration in seconds', 
    version='1.0.0'
)
```

**备份和恢复脚本**：

```bash
#!/bin/bash
# backup.sh

# 数据库备份
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
BACKUP_DIR="/backups"
DB_BACKUP_FILE="$BACKUP_DIR/db_backup_$TIMESTAMP.sql"

# PostgreSQL备份
pg_dump -h localhost -U user production_db > $DB_BACKUP_FILE

# 应用代码备份
tar -czf "$BACKUP_DIR/app_backup_$TIMESTAMP.tar.gz" /path/to/your/app

# 上传到云存储
aws s3 cp $DB_BACKUP_FILE s3://your-bucket/backups/
aws s3 cp "$BACKUP_DIR/app_backup_$TIMESTAMP.tar.gz" s3://your-bucket/backups/

# 清理旧备份（保留最近7天）
find $BACKUP_DIR -name "*.sql" -mtime +7 -delete
find $BACKUP_DIR -name "*.tar.gz" -mtime +7 -delete
```

以下图表展示了生产环境的部署架构：

```mermaid
flowchart TD
    A[客户端] --> B[CDN]
    B --> C[负载均衡器]
    C --> D[Nginx反向代理]
    D --> E[Gunicorn WSGI服务器]
    E --> F[Flask应用]
    
    F --> G[数据库]
    F --> H[Redis缓存]
    F --> I[外部API]
    
    subgraph "监控系统"
        J[Prometheus]
        K[Grafana]
        L[Alertmanager]
    end
    
    F --> J
    J --> K
    J --> L
    
    subgraph "日志系统"
        M[ELK Stack]
        N[Fluentd]
    end
    
    F --> N
    N --> M
```

**部署流程**：

```mermaid
flowchart LR
    A[代码仓库] --> B[CI/CD流水线]
    B --> C[自动化测试]
    C --> D[构建Docker镜像]
    D --> E[部署到 staging]
    E --> F[人工验证]
    F --> G[部署到生产]
    G --> H[健康检查]
    H --> I[监控验证]
    
    subgraph "回滚机制"
        J[发现问题]
        K[自动回滚]
        L[通知团队]
    end
    
    I --> J
    J --> K
    K --> L
```

**监控告警体系**：

```mermaid
flowchart TD
    A[应用指标] --> B[Prometheus]
    C[系统指标] --> B
    D[业务指标] --> B
    
    B --> E[告警规则]
    E --> F[Alertmanager]
    F --> G[通知渠道]
    
    G --> H[邮件通知]
    G --> I[Slack通知]
    G --> J[SMS通知]
    
    B --> K[Grafana]
    K --> L[监控仪表盘]
```

本章详细介绍了 Flask 应用在生产环境的部署和维护，涵盖了从配置准备、WSGI服务器设置、云平台部署到监控维护的完整流程。通过遵循这些最佳实践，可以确保 Flask 应用在生产环境中稳定、安全、高效地运行。

