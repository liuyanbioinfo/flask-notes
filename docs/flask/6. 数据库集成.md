# 6. 数据库集成
## 6.1 数据库选择（SQLite、MySQL、PostgreSQL）
Flask 可以与多种数据库系统集成，从轻量级的 SQLite 到功能强大的 PostgreSQL。

**数据库选择指南**：

| 数据库 | 适用场景 | 优点 | 缺点 |
| --- | --- | --- | --- |
| **SQLite** | 小型应用、原型开发、测试 | 无需服务器、零配置、文件数据库 | 并发性能有限、无网络访问 |
| **MySQL** | 中小型Web应用、通用场景 | 成熟稳定、社区支持好、性能良好 | 某些高级功能缺失 |
| **PostgreSQL** | 大型应用、复杂数据需求 | 功能丰富、标准兼容性好、扩展性强 | 配置相对复杂、资源消耗较高 |


**数据库URL格式**：

+ SQLite: `sqlite:///database.db`
+ MySQL: `mysql://username:password@host/database`
+ PostgreSQL: `postgresql://username:password@host/database`

## 6.2 使用 SQLAlchemy ORM
SQLAlchemy 是 Python 中最流行的 ORM（对象关系映射）工具，Flask-SQLAlchemy 扩展使其与 Flask 集成更加简便。

### 6.2.1 安装和配置
**安装必要的扩展**：

```bash
pip install flask-sqlalchemy
```

**配置数据库连接**：

```python
from flask_sqlalchemy import SQLAlchemy

app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///app.db'
app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False  # 禁用追踪修改，节省资源
app.config['SQLALCHEMY_ECHO'] = True  # 开发时显示SQL语句

db = SQLAlchemy(app)
```

**生产环境配置示例**：

```python
import os
from dotenv import load_dotenv

load_dotenv()  # 加载环境变量

# 根据环境选择数据库
if os.environ.get('FLASK_ENV') == 'production':
    app.config['SQLALCHEMY_DATABASE_URI'] = os.environ.get('DATABASE_URL')
else:
    app.config['SQLALCHEMY_DATABASE_URI'] = 'sqlite:///dev.db'

app.config['SQLALCHEMY_TRACK_MODIFICATIONS'] = False
```

### 6.2.2 定义模型类
**基本模型定义**：

```python
from datetime import datetime

class User(db.Model):
    __tablename__ = 'users'
    
    id = db.Column(db.Integer, primary_key=True)
    username = db.Column(db.String(80), unique=True, nullable=False)
    email = db.Column(db.String(120), unique=True, nullable=False)
    password_hash = db.Column(db.String(128))
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    is_active = db.Column(db.Boolean, default=True)
    
    # 定义关系
    posts = db.relationship('Post', backref='author', lazy='dynamic')
    profile = db.relationship('Profile', backref='user', uselist=False)
    
    def __repr__(self):
        return f'<User {self.username}>'

class Post(db.Model):
    __tablename__ = 'posts'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=False)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    is_published = db.Column(db.Boolean, default=False)
    
    # 外键关系
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'))
    
    # 多对多关系
    tags = db.relationship('Tag', secondary='post_tags', backref=db.backref('posts', lazy='dynamic'))
    
    def __repr__(self):
        return f'<Post {self.title}>'

class Profile(db.Model):
    __tablename__ = 'profiles'
    
    id = db.Column(db.Integer, primary_key=True)
    full_name = db.Column(db.String(100))
    bio = db.Column(db.Text)
    website = db.Column(db.String(200))
    
    user_id = db.Column(db.Integer, db.ForeignKey('users.id'), unique=True)
    
    def __repr__(self):
        return f'<Profile {self.full_name}>'

# 多对多关联表
post_tags = db.Table('post_tags',
    db.Column('post_id', db.Integer, db.ForeignKey('posts.id'), primary_key=True),
    db.Column('tag_id', db.Integer, db.ForeignKey('tags.id'), primary_key=True)
)

class Tag(db.Model):
    __tablename__ = 'tags'
    
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(50), unique=True, nullable=False)
    
    def __repr__(self):
        return f'<Tag {self.name}>'
```

### 6.2.3 基本 CRUD 操作
**创建记录**：

```python
# 创建单个记录
new_user = User(username='john', email='john@example.com')
db.session.add(new_user)
db.session.commit()

# 批量创建
users = [
    User(username='alice', email='alice@example.com'),
    User(username='bob', email='bob@example.com')
]
db.session.add_all(users)
db.session.commit()
```

**查询记录**：

```python
# 获取所有记录
all_users = User.query.all()

# 获取单个记录
user = User.query.get(1)  # 通过主键获取
user = User.query.filter_by(username='john').first()

# 复杂查询
active_users = User.query.filter_by(is_active=True).all()
recent_users = User.query.filter(User.created_at > datetime(2023, 1, 1)).all()

# 排序和限制
users_ordered = User.query.order_by(User.username).all()
limited_users = User.query.limit(10).offset(5).all()

# 聚合查询
user_count = User.query.count()
active_count = User.query.filter_by(is_active=True).count()
```

**更新记录**：

```python
user = User.query.get(1)
user.email = 'newemail@example.com'
db.session.commit()

# 批量更新
User.query.filter_by(is_active=False).update({'is_active': True})
db.session.commit()
```

**删除记录**：

```python
user = User.query.get(1)
db.session.delete(user)
db.session.commit()

# 批量删除
User.query.filter_by(is_active=False).delete()
db.session.commit()
```

## 6.3 数据库迁移（使用 Flask-Migrate）
数据库迁移是管理数据库模式变更的重要工具，Flask-Migrate 基于 Alembic 提供了简单的迁移功能。

**安装 Flask-Migrate**：

```bash
pip install flask-migrate
```

**初始化迁移环境**：

```python
from flask_migrate import Migrate

migrate = Migrate(app, db)
```

**使用迁移命令**：

```bash
# 初始化迁移仓库（只需执行一次）
flask db init

# 生成迁移脚本
flask db migrate -m "Initial migration"

# 应用迁移
flask db upgrade

# 回滚迁移
flask db downgrade

# 查看当前迁移状态
flask db current

# 查看迁移历史
flask db history
```

**迁移脚本示例**：

```python
# migrations/versions/1234567890_initial_migration.py

from alembic import op
import sqlalchemy as sa

def upgrade():
    # 创建表
    op.create_table('users',
        sa.Column('id', sa.Integer(), nullable=False),
        sa.Column('username', sa.String(length=80), nullable=False),
        sa.Column('email', sa.String(length=120), nullable=False),
        sa.PrimaryKeyConstraint('id'),
        sa.UniqueConstraint('email'),
        sa.UniqueConstraint('username')
    )
    
    # 添加列
    op.add_column('users', sa.Column('created_at', sa.DateTime(), nullable=True))
    
    # 创建索引
    op.create_index(op.f('ix_users_created_at'), 'users', ['created_at'], unique=False)

def downgrade():
    # 删除索引
    op.drop_index(op.f('ix_users_created_at'), table_name='users')
    
    # 删除列
    op.drop_column('users', 'created_at')
    
    # 删除表
    op.drop_table('users')
```

## 6.4 数据库关系可视化
以下 Mermaid 图展示了示例中的数据模型关系：

```mermaid
erDiagram
    USER ||--o{ POST : "作者"
    USER ||--|| PROFILE : "拥有"
    POST }o--o{ TAG : "标签"
    
    USER {
        int id PK
        string username
        string email
        string password_hash
        datetime created_at
        boolean is_active
    }
    
    POST {
        int id PK
        string title
        text content
        datetime created_at
        datetime updated_at
        boolean is_published
        int user_id FK
    }
    
    PROFILE {
        int id PK
        string full_name
        text bio
        string website
        int user_id FK
    }
    
    TAG {
        int id PK
        string name
    }
    
    POST_TAGS {
        int post_id PK,FK
        int tag_id PK,FK
    }
```

**数据库操作流程**：

```mermaid
flowchart TD
    A[客户端请求] --> B[Flask 视图函数]
    B --> C[SQLAlchemy ORM 操作]
    C --> D[生成 SQL 语句]
    D --> E[数据库执行]
    E --> F[返回结果]
    F --> G[ORM 转换为对象]
    G --> H[返回响应给客户端]
    
    subgraph "数据库迁移流程"
        I[修改数据模型] --> J[生成迁移脚本]
        J --> K[审查迁移脚本]
        K --> L[应用迁移]
        L --> M[更新数据库结构]
    end
```

## 6.5 高级查询和性能优化
**连接查询**：

```python
# 基本连接查询
posts_with_authors = db.session.query(Post, User).join(User).all()

# 复杂连接查询
recent_posts = (db.session.query(Post.title, User.username)
                .join(User)
                .filter(Post.is_published == True)
                .order_by(Post.created_at.desc())
                .limit(10)
                .all())
```

**聚合查询**：

```python
from sqlalchemy import func

# 基本聚合
post_count = db.session.query(func.count(Post.id)).scalar()
user_post_counts = (db.session.query(User.username, func.count(Post.id))
                    .join(Post)
                    .group_by(User.id)
                    .all())

# 高级聚合
avg_post_length = db.session.query(func.avg(func.length(Post.content))).scalar()
```

**性能优化技巧**：

```python
# 使用 eager loading 避免 N+1 查询问题
posts = Post.query.options(db.joinedload(Post.author)).all()

# 只选择需要的列
users = User.query.with_entities(User.id, User.username).all()

# 使用索引优化查询
class Post(db.Model):
    # ...
    __table_args__ = (
        db.Index('ix_posts_created_at', 'created_at'),
        db.Index('ix_posts_user_id_created_at', 'user_id', 'created_at'),
    )
```

**数据库事件监听**：

```python
from sqlalchemy import event

@event.listens_for(User, 'before_insert')
def hash_password(mapper, connection, target):
    if target.password:
        target.password_hash = generate_password_hash(target.password)

@event.listens_for(Post, 'before_update')
def update_timestamp(mapper, connection, target):
    target.updated_at = datetime.utcnow()
```

本章详细介绍了 Flask 与数据库的集成，从基本的模型定义到复杂的查询操作，以及数据库迁移和性能优化。通过合理使用 SQLAlchemy ORM 和 Flask-Migrate，可以高效地管理应用程序的数据层，确保数据的一致性和完整性。

